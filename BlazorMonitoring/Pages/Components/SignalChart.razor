@using FM4017Library.Dtos
@using FM4017Library.Helpers

<SfChart>
    <ChartPrimaryXAxis Format="HH:mm" ValueType="Syncfusion.Blazor.Charts.ValueType.DateTime" /> @*Title="TimeStamp"*@
    @*<ChartPrimaryYAxis Title="Value" />*@
    <ChartZoomSettings EnableMouseWheelZooming="true" EnablePinchZooming="true" EnableSelectionZooming="true"></ChartZoomSettings>
    <ChartTooltipSettings Enable="true" />
    <ChartLegendSettings Visible="true" Position="LegendPosition.Top" />
    <ChartSeriesCollection>
        @foreach (var signalsList in UniqueSignalsLists)
        {
            <ChartSeries
                DataSource="@signalsList"
                Name="@(Prettify.Unit(signalsList?.FirstOrDefault()?.Unit))" 
                XName="TimeStamp" 
                YName="Value" 
                Type="ChartSeriesType.Line">
            </ChartSeries>
        }
    </ChartSeriesCollection>
</SfChart>

@code {
    [Parameter]
    public List<SignalNode>? SignalNodes { get; set; }

    public List<List<Signal>> UniqueSignalsLists
    {
        get
        {
            List<List<Signal>> result = new ();

            List<string?> uniqueUnits = SignalNodeHelpers.ListUniqueUnits(SignalNodes);

            // Create a list of signals with each unique unit
            if (uniqueUnits is not null)
            {
                foreach (var uniqeUnit in uniqueUnits)
                {
                    // holds result per unit
                    List<Signal> unitResult = new();

                    foreach (var signal in SignalNodes!.Where(t => t.Unit == uniqeUnit))
                    {
                        if (signal?.Timestamp is not null)
                        {
                            unitResult.Add(new Signal
                                {
                                    TimeStamp = DateTimeHelpers.UtcTime2Local(signal.Timestamp.Value),
                                    Value = Convert.ToDouble(signal?.Data?.RawValue),
                                    Unit = signal?.Unit
                        });
                        }
                    }

                    result.Add(unitResult);
                }

            }

            #region filter based on metadata- channel if not null 

            // If channel is not null filter by channel (changed by dataloggin group 27.10.22)
            if (SignalNodes?.LastOrDefault()?.Metadata?.Channel is not null)
            {
                result.Clear();

                // Get list of signal with unique channel
                var uniqueChannelSignalNodes = SignalNodes?.DistinctBy(signal => signal?.Metadata?.Channel).ToList();
                // Only display channel 1
                List<string?> uniqueChannels = new() {"1"};

                // display all channels
                //if (uniqueChannelSignalNodes is not null)
                //{
                //    foreach (var uniqueChannelSignalNode in uniqueChannelSignalNodes)
                //    {
                //        if (uniqueChannelSignalNode?.Metadata?.Channel! is not null)
                //        {
                //            uniqueChannels.Add(uniqueChannelSignalNode?.Metadata?.Channel!);
                //        }
                //    }
                //}

                foreach (var uniqueChannel in uniqueChannels)
                {
                    // holds result per unit
                    List<Signal> channelResult = new();

                    foreach (var signal in SignalNodes!.Where(t => t.Metadata.Channel == uniqueChannel))
                    {
                        if (signal?.Timestamp is not null)
                        {
                            channelResult.Add(new Signal
                                {
                                    TimeStamp = DateTimeHelpers.UtcTime2Local(signal.Timestamp.Value),
                                    Value = Convert.ToDouble(signal?.Data?.RawValue),
                                    Unit = signal?.Unit
                                });
                        }
                    }

                    result.Add(channelResult);
                }
            }
            
            #endregion

            return result;
        }
    }

    public class Signal
    {
        public DateTime? TimeStamp { get; set; }
        public double Value { get; set; }
        public string? Unit { get; set; }
    }
}
